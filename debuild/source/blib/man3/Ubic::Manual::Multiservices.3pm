.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Ubic::Manual::Multiservices 3"
.TH Ubic::Manual::Multiservices 3 "2011-06-07" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Ubic::Manual::Multiservices \- Multiservices \- dynamic generation of service tree
.SH "VERSION"
.IX Header "VERSION"
version 1.29
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Multiservice is an object which tells ubic what services you have.
.PP
In other words, multiservices populate service tree by providing simple list/get, virtual-filesystem-like \s-1API\s0.  This \s-1API\s0 is documented in Ubic::Multiservice abstract class.
.PP
Even the configs in your ubic service dir are loaded by Ubic::Multiservice::Dir instance. This instance is named \fIroot_service\fR and can be obtained via \f(CW\*(C`root_service()\*(C'\fR method in Ubic module.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
There are several common use cases for multiservices.
.Sh "Simple multiservice with several parts"
.IX Subsection "Simple multiservice with several parts"
Some services are meant to work together. For example, your project can consist of \s-1PSGI\s0 app, memcached process and nginx frontend (yes, you can run nginx with ubic if you want to). You can just put them all in subdirectory in your service dir:
.PP
.Vb 4
\&    $ ls \-1 /etc/ubic/service/my/
\&    app
\&    memcached
\&    nginx
.Ve
.PP
They all will be loaded by root multiservice, since \f(CW\*(C`Ubic::Multiservice::Dir\*(C'\fR does traverse subdirectories:
.PP
.Vb 5
\&    $ ubic status my
\&    my
\&        my.app          running
\&        my.memcached    running
\&        my.nginx        running
.Ve
.PP
(You can see another example in \f(CW\*(C`ubic.*\*(C'\fR services which you have out of the box in common ubic installation).
.PP
On the other hand, maybe your three services are tightly coupled and you don't want to copy-paste memcached port both to \fImy.app\fR service declaration and \fImy.memcached\fR.  In this case, you can create all three services in one file:
.PP
.Vb 2
\&    # content of the file /etc/ubic/service/my
\&    use Ubic::Multiservice::Simple;
.Ve
.PP
.Vb 3
\&    my $app_service = ...;
\&    my $memcached_service = ...;
\&    my $nginx_service = ...;
.Ve
.PP
.Vb 5
\&    Ubic::Multiservice::Simple\->new({
\&        app => $app_service,
\&        memcached => $memcached_service,
\&        nginx => $nginx_service,
\&    });
.Ve
.Sh "Simple multiservice with several workers"
.IX Subsection "Simple multiservice with several workers"
This example is similar to the previous one, but it solves a different task.
.PP
What if you have only one program, but want to run several instances of it? For example, your process may be some kind of a fetching robot which fetches the list of urls and stores them in external database, and you want to make it run in parallel, either because with to utilize multiple CPUs, or you're just don't want to learn parallel programming techniques.
.PP
Anyway, here is the example:
.PP
.Vb 3
\&    # content of the file /etc/ubic/service/robot
\&    use Ubic::Multiservice::Simple;
\&    use Ubic::Service::SimpleDaemon;
.Ve
.PP
.Vb 1
\&    my $robot_service = Ubic::Service::SimpleDaemon\->new(bin => "/usr/bin/fetching_robot.pl");
.Ve
.PP
.Vb 5
\&    Ubic::Multiservice::Simple\->new({
\&        map {
\&            "robot$_" => Ubic::Service::SimpleDaemon\->new(bin => "/usr/bin/fetching_robot.pl")
\&        } (1..10)
\&    });
.Ve
.PP
Note that you could easily alter some properties of each service, for example, pass \f(CW\*(C`stdout\*(C'\fR option to SimpleDaemon constructor with different log file for every process.
.PP
By the way, this example is easy and powerful, but please consider other options if your number of services will get high (more than tens of workers). Ubic watchdog checks each service separately and forks once or even twice per service, so it can create pretty high \s-1CPU\s0 overhead.
.SH "Dynamic multiservice with external configs"
.IX Header "Dynamic multiservice with external configs"
Let's assume that a fetching robot from the previous example uses files in multiple local directories \f(CW\*(C`/var/spool/fetching_robot/queues/*\*(C'\fR as the list of urls to process.
Let's also assume that you don't want to run multiple workers to parallel your fetching, but you want to process each queue in separate process.
.PP
You may declare one service per queue, but it's double work. And there is a better solution: let's implement multiservice which creates as many services as there are queues.
.PP
.Vb 2
\&    # content of the file /etc/ubic/service/robot
\&    use parent qw(Ubic::Multiservice);
.Ve
.PP
.Vb 1
\&    my $queue_dir = "/var/spool/fetching_robot/queues";
.Ve
.PP
.Vb 3
\&    sub new {
\&        return bless {} => shift;
\&    }
.Ve
.PP
.Vb 3
\&    sub service_names {
\&        return map { s{^\eQ$queue_dir/\eE}{} } glob "$queue_dir/*";
\&    }
.Ve
.PP
.Vb 6
\&    sub simple_service {
\&        my ($self, $name) = @_;
\&        return Ubic::Service::SimpleDaemon\->new(
\&            bin => ["/usr/bin/fetching_robot.pl", "\-\-queue\-dir", "$queue_dir/$name"]
\&        );
\&    }
.Ve
.PP
.Vb 1
\&    __PACKAGE__\->new;
.Ve
.PP
You could also implement this multiservice as simple service, but this code is theoretically more efficient: it doesn't create subservice object until it is asked to do so.
.PP
You can apply the similar technique to write service declarations in any config format you want, transforming these configs into service objects by some multiservice.
.PP
Important side note: don't forget to stop the service before removing the config (or in this case, queue dir). Ubic won't remember that service was running if it's not present in service tree!
.SH "AUTHOR"
.IX Header "AUTHOR"
Vyacheslav Matyukhin <mmcleric@yandex\-team.ru>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2011 by Yandex \s-1LLC\s0.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
